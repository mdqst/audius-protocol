import { CID, ID, UID } from '../models/Identifiers'
import { CoverArtSizes, CoverArtSizesCids } from '../models/ImageSizes'
import { Repost } from '../models/Repost'
import { Nullable } from '../utils/typeUtils'

import { Favorite } from './Favorite'
import {
  AccessConditions,
  UserTrackMetadata,
  ResourceContributor,
  Copyright,
  AccessPermissions
} from './Track'
import { User, UserMetadata } from './User'

export enum Variant {
  USER_GENERATED = 'user-generated',
  SMART = 'smart'
}

export type PlaylistTrackId = {
  time: number
  track: ID
  metadata_time?: number
  uid?: UID
}

export type PlaylistContents = {
  track_ids: Array<PlaylistTrackId | { track: string }>
}

export type CollectionMetadata = {
  blocknumber: number
  variant: Variant.USER_GENERATED
  description: Nullable<string>
  followee_reposts: Repost[]
  followee_saves: Favorite[]
  has_current_user_reposted: boolean
  has_current_user_saved: boolean
  is_album: boolean
  is_delete: boolean
  is_image_autogenerated?: boolean
  is_private: boolean
  artwork: CoverArtSizes & { mirrors?: string[] | undefined }
  playlist_contents: {
    track_ids: PlaylistTrackId[]
  }
  tracks?: UserTrackMetadata[]
  track_count: number
  playlist_id: ID
  cover_art: CID | null
  cover_art_sizes: Nullable<CID>
  cover_art_cids?: Nullable<CoverArtSizesCids>
  permalink: string
  playlist_name: string
  playlist_owner_id: ID
  repost_count: number
  save_count: number
  upc?: string | null
  created_at: string
  updated_at: string
  activity_timestamp?: string
  playlist_image_multihash?: string
  playlist_image_sizes_multihash?: string
  offline?: OfflineCollectionMetadata
  local?: boolean
  release_date: Nullable<string>
  is_scheduled_release: boolean
  ddex_app?: string | null
  is_stream_gated: boolean
  stream_conditions: Nullable<AccessConditions>
  access: AccessPermissions
  ddex_release_ids?: any | null
  artists?: ResourceContributor[] | null
  copyright_line?: Copyright | null
  producer_copyright_line?: Copyright | null
  parental_warning_type?: string | null
}

export type CollectionDownloadReason = { is_from_favorites: boolean }

// This is available on mobile for offline tracks
export type OfflineCollectionMetadata = {
  reasons_for_download: CollectionDownloadReason[]
}

export type ComputedCollectionProperties = {
  _is_publishing?: boolean
  _marked_deleted?: boolean
  _cover_art_sizes: CoverArtSizes
  _moved?: UID
  _temp?: boolean
  artwork?: CollectionMetadata['artwork'] & {
    file?: File
    url?: string
    source?: string
    error?: string
  }
}

export type Collection = CollectionMetadata & ComputedCollectionProperties

export type UserCollectionMetadata = CollectionMetadata & { user: UserMetadata }

export type UserCollection = Collection & {
  user: User
}

export type SmartCollection = {
  variant: Variant.SMART
  playlist_name: string
  description?: string
  makeDescription?: (...args: any) => string
  // Where this type of playlist is given a different classification
  // e.g. "Audio NFT Playlist" instead of just "Playlist"
  typeTitle?: 'Playlist' | 'Audio NFT Playlist'
  gradient?: string
  imageOverride?: string
  shadow?: string
  link: string
  playlist_contents?: PlaylistContents
  has_current_user_saved?: boolean
  incentivized?: boolean // Whether we reward winners with Audio
  cardSensitivity?: number
  customEmptyText?: string
  ddex_app?: string | null
}

export type CollectionImage = {
  cover_art: Nullable<CID>
  cover_art_sizes: Nullable<CID>
  cover_art_cids?: Nullable<CoverArtSizesCids>
}

/** A minimal record of a collection saved to an account. Can be used to fetch
 * a full Collection record if extended metadata is needed.
 */
export type AccountCollection = {
  id: ID
  name: string
  is_album: boolean
  user: { id: ID; handle: string; is_deactivated?: boolean }
  permalink: string
}
